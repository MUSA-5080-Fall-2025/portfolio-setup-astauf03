ggplot(mpg, aes(x=class, y=class, linewidth = class))+geom_point()
ggplot(mpg, aes(x=class, y=class, linewidth = class, color=class))+geom_point()
ggplot(penguins, aes(x=bill_depth_mm,y=bill_length_mm, color=species))+geom_point()
ggplot(penguins, aes(x=bill_depth_mm,y=bill_length_mm, color=species))+geom_point(facet_wrap(~species))
ggplot(penguins, aes(x=bill_depth_mm,y=bill_length_mm, color=species, facet_wrap(~species)))+geom_point()
ggplot(penguins, aes(x=bill_length_mm,y=bill_depth_mm, color=species,shape = species))+geom_point()+labs(color="Species")
ggplot(penguins, aes(x=bill_length_mm,y=bill_depth_mm, color=species,shape = species))+geom_point()+labs(color="Species", shape="Species")
ggplot(penguins, aes(x=island, fill=species))+geom_bar(position="fill")
ggplot(penguins, aes(x=species, fill=island))+geom_bar(position="fill")
ggplot(penguins, aes(flipper_length_mm,y=body_mass_g))+geom_point()
ggsave(filename="penguin-plot.png")
1/200*30
(59+73+2)/3
sin(pi/2)
x <- 3*4
x
x <- 3
x
library(nycflights13)
?nycflights13
glimpse(nycflights13)
view(nycflights13)
data(nycflights13)
library(ggplot)
library(tidyverse
)
library(nycflights13)
glimpse(nycflights13)
nycflights13::flights
library(tidyverse)
library(nycflights13)
nycflights13::flights
glimpse(flights)
flights |>
filter(dest=="IAH")|>
group_by(year,month,day) |>
summarize(arr_delay =mean(arr_delay, na.rm = TRUE))
flights|>
filter(dep_delay > 120)
flights|>
filter(month ==1, day==1)
flights|>
filter(month==1|month==2)
flights |>
filter(month%in%c(1,2))
jan1 <- flights|>
filter(month==1 & day==1)
flights |>
arrange(year,month,day,dep_time)
flights |>
arrange(desc(dep_delay))
flights |>
distinct()
flights |>
distinct(origin,dest)
flights |>
count(origin,dest, sort=TRUE)
flights |>
filter(arr_delay > 120)|>
flights |>
filter(arr_delay > 120)|>
distinct(dest%in%c(IAH,HOU))
distinct(dest%in%c("IAH","HOU"))
flights |>
filter(arr_delay > 120)|>
distinct(dest%in%("IAH","HOU"))
flights |>
filter(arr_delay >= 120)
flights |>
filter(arr_delay >= 120)|>
flights |>
filter(dest%in%c("IAH","HOU"))
flights |>
airlines
flights |>
filter(carrier%in%c("UA","AA","DL"))
flights |>
filter(month%in%c("July","August","September"))
flights |>
filter(month%in%c(7,8,9))
flights |>
filter(arr_delay > 120 & dep_delay ==0)
flights |>
filter(arr_delay >= 120 & dep_delay <=0)
flights |>
filter(dep_delay>=60 & dep_delay - arr_delay >30)
flights |>
arrange(desc(dep_delay))
flights |>
arrange(desc(dep_delay))|>
arrange(sched_dep_time)
flights |>
arrange(desc(dep_delay))|>
arrange(sched_dep_time)|>
relocate(dep_delay, sched_dep_time)
library(tidyverse)
library(ggplot2)
library(nycflights13)
nycflights13::flights
flights |>
arrange(desc(dep_delay))
flights |>
arrange(desc(dep_delay))
flights |>
arrange(desc(dep_delay))|>
relocate(dep_delay,sched_dep)
flights |>
arrange(desc(dep_delay))|>
relocate(dep_delay,sched_dep_time)
flights |>
arrange(desc(dep_delay))|>
arrange(sched_dep_time)|>
relocate(dep_delay,sched_dep_time)
?flights
flights |>
mutate(speed=distance/(air_time/60))|>
arrange(desc(speed))|>
relocate(speed)
flights |>
filter(2013)
flights |>
arrange(year=2013)
flights |>
distinct(year, month, day)|>
nrow()
flights>
flights |>
arrange(desc(distance))
flights |>
arrange(desc(distance))|>
relocate(distance)
flights |>
mutate(gain=dep_delay-arr_delay, speed = distance/(air_time*60))
flights |>
mutate(gain=dep_delay-arr_delay, speed = distance/(air_time*60))|>
.before=1
flights |>
mutate(gain=dep_delay-arr_delay, speed = distance/(air_time*60),.before=1)
flights |>
mutate(gain=dep_delay-arr_delay, speed = distance/(air_time*60),.after=day
)
library(nycflights13)
library(tidyverse)
nycflights13::flights
5!
factorial(5)
factorial(0)
help(operations)
??operations
help(mathfunctions)
help("Math2")
log(help)
log(54)
log(10,54)
dpois(1,3)
dpois(2,3)
dpois(4,3)
pnorm(2.18)
pnorm(-2.18)
dpois(8,1.6)
pnorm(125,120,18)
1-pnorm(125,120,18)
pnorm(100,120,18)
pnorm(124,120,18)-pnorm(110,120,18)
pnorm(138,120,18)-pnorm(102,120,18)
pnorm(120.01,120,18)-pnorm(119.99,120,18)
print("hello world")
string_object <- "derp"
string_object = "quack"
numeric_object <- 5
numeric_object + 2
vector_object <- c("schwarber", "turner", "harper", "bohm", "realmuto", "castellanos", "stott", "sosa", "rojas")
library(tidyverse)
library(sf)
install.packages('sf')
library(sf)
phila_tracts <- read.csv("https://raw.githubusercontent.com/mafichman/cpln_0795/main/data/philadelphia_tracts_2020.csv")
glimpse(phila_tracts)
view(phila_tracts)
glimpse(phila_tracts)
??glimpse
library(dplyr)
glimpse(phila_tracts)
mean(phila_tracts$pop)
just_two_columns <- phila_tracts %>%
select(GEOID, tract)
View(just_two_columns)
some_new_column_names <- phila_tracts %>%
rename(tracty_mctracterson = tract,
unique_ID = GEOID)
View(some_new_column_names)
View(phila_tracts)
phila_tracts <- phila_tracts %>%
mutate(pct_own = 100*(owner_hh/hhs),
majority_white = ifelse(pct_wht > 50, "Majority White", "Majority Non-White"))
View(phila_tracts)
phila_tracts_sf <- st_read("https://raw.githubusercontent.com/mafichman/cpln_0795/main/data/philadelphia_tracts_no_data.geojson")
glimpse(phila_tracts_sf)
phila_tracts %>%
group_by(majority_white)%>%
summarize(total_pop = sum(pop))
glimpse(phila_tracts_sf)
View(phila_tracts_sf)
st_crs(phila_tracts_sf)
phila_tracts_sf %>%
st_transform(crs = 2272)
tracts_with_data <- left_join(phila_tracts_sf, phila_tracts, by = "NAME")
glimpse(tracts_with_data)
tracts_with_data <- tracts_with_data %>%
select(-tract.y, -GEOID.y) %>%
rename(GEOID = GEOID.x,
tract = tract.x)
ggplot()+
geom_histogram(data = tracts_with_data,
aes(med_inc))
library(ggplot2)
ggplot()+
geom_histogram(data = tracts_with_data,
aes(med_inc))
ggplot()+
geom_histogram(data = tracts_with_data,
aes(med_inc)) +
theme_bw()
ggplot()+
geom_histogram(data = tracts_with_data,
aes(med_inc)) +
labs(
title = "Median Household Income, Philadelphia Census Tracts, 2020",
subtitle = "The Average Tract's Median HH Income is appx $26,700",
x="Dollars (not inflation adjusted)",
y="Number of Tracts",
caption = "Data: American Community Survey 5-year estimates")+
theme_bw()
ggplot()+
geom_histogram(data = tracts_with_data,
aes(med_inc)) +
facet_wrap(~majority_white)+
labs(
title = "Median Household Income, Philadelphia Census Tracts, 2020",
subtitle = "The Average Tract's Median HH Income is appx $26,700",
x="Dollars (not inflation adjusted)",
y="Number of Tracts",
caption = "Data: American Community Survey 5-year estimates")+
theme_bw()
ggplot()+
geom_sf(data = tracts_with_data,
aes(fill = med_inc), color = "transparent")+
theme_minimal()
knitr::opts_chunk$set(echo = TRUE)
```{r, echo=FALSE, message=FALSE}
# Load required libraries
library(tidyverse)
library(tidycensus)
library(sf)
library(tigris)
install.packages("tidycensus")
install.packages("tigris")
knitr::opts_chunk$set(echo = TRUE)
# Load required libraries
library(tidyverse)
library(tidycensus)
library(sf)
library(tigris)
census_api_key("eeb46a4e68d059982c2b048f843063e19bc4c294", overwrite = TRUE)
acs_variable_list <- load_variables(2020, #year
"acs5", #five year ACS estimates
cache = TRUE)
View(acs_variable_list)
acs_vars <- c("B01001_001E", # ACS total Pop estimate
"C02003_004E", # One race black
"C02003_003E", # One race white
"B03001_003E", # Hispanic (all)
"B02001_005E", # AAPI
"B11012_001E", # n Households
"B08137_003E", # Renter hh
"B08137_002E", # owner hh
"B06011_001E") # Median income in past 12 months
View(acs_variable_list)
??get_acs
acs2020 <- get_acs(geography = "tract",
year = 2020,
variables = acs_vars,
geometry = TRUE,
state = "PA",
county = "Philadelphia",
output = "wide")
View(acs2020)
study_areas <- st_read("https://raw.githubusercontent.com/mafichman/cpln_6890/refs/heads/main/study_areas/2025/geojson/study_areas_2025.geojson")
knitr::opts_chunk$set(echo = TRUE)
# Load required libraries
library(tidyverse)
library(tidycensus)
library(sf)
library(tigris)
study_areas <- st_read("https://raw.githubusercontent.com/mafichman/cpln_6890/refs/heads/main/study_areas/2025/geojson/study_areas_2025.geojson")
setwd("C:/Users/astau/OneDrive - PennO365/MUSA_5080_PPA/lab1")
# Load required packages (hint: you need tidycensus, tidyverse, and knitr)
library(tidycensus)
library(tidyverse)
library(knitr)
# Set your Census API key
census_api_key("eeb46a4e68d059982c2b048f843063e19bc4c294")
# Choose your state for analysis - assign it to a variable called my_state
my_state <- "MI"
rm(acs2020)
rm(acs_variable_list, acs_vars)
# Write your get_acs() code here
county_data_2022 <- get_acs(geography = "county",
state = "MI",
variables = c(median_household_income = "B19013_001", total_pop = "B01003_001" ),
year = 2022,
survey = "acs5",
output = "wide")
# Clean the county names to remove state name and "County"
county_data_2022 <- county_data_2022 %>%
mutate(county_data_2022_clean = str_remove(NAME,paste0("County, Michigan")))
# Hint: use mutate() with str_remove()
# Display the first few rows
glimpse(county_data_2022)
View(county_data_2022)
# Load required packages (hint: you need tidycensus, tidyverse, and knitr)
library(tidycensus)
library(tidyverse)
library(knitr)
# Set your Census API key
census_api_key("eeb46a4e68d059982c2b048f843063e19bc4c294")
# Choose your state for analysis - assign it to a variable called my_state
my_state <- "MI"
# Write your get_acs() code here
county_data_2022 <- get_acs(geography = "county",
state = "MI",
variables = c(med_household_income = "B19013_001", total_pop = "B01003_001" ),
year = 2022,
survey = "acs5",
output = "wide")
# Clean the county names to remove state name and "County"
county_data_2022 <- county_data_2022 %>%
mutate(county_data_2022_clean = str_remove(NAME,paste0("County, Michigan")))
# Hint: use mutate() with str_remove()
# Display the first few rows
head(county_data_2022)
# Calculate MOE percentage and reliability categories using mutate()
MI_county_reliablility <- county_data_2022 %>%
mutate(
med_income_moe_pct = (med_household_incomeM / med_household_incomeE) * 100,
med_income_confi = case_when(
med_income_moe_pct < 5 ~ "High Confidence (<5%)",
med_income_moe_pct > 5 & med_income_moe_pct <10 ~ "Moderate Confidence (5% - 10%)",
med_income_moe_pct > 10  ~ "Low Confidence (>10%)"
)
)
# Create a summary showing count of counties in each reliability category
MI_reability_data <- MI_county_reliablility %>%
count(med_income_confi)%>%
mutate(percentage = round(n/sum(n)*100, 2))
kable(MI_reability_data,
caption = "**MI Reliability Summary**",
align = c("l", "c", "r"),
digits = 2,
row.names = TRUE,
col.names = c("Confidence", "Count", "Percentage")
)
# Hint: use count() and mutate() to add percentages
# Create table of top 5 counties by MOE percentage
top5_byMOE <- MI_county_reliablility %>%
arrange(desc(med_income_moe_pct))%>%
slice(1:5)%>%
select(county_data_2022_clean, med_household_incomeE, med_household_incomeM, med_income_moe_pct, med_income_confi)
kable(top5_byMOE,
caption = "**Top 5 Counties by MOE Percentage**",
align = c("l", "c", "c", "c", "r"),
digits = 2,
row.names = TRUE,
col.names = c("County", "Med. Household Income", "Income MOE", "MOE %", "Confidence Intervals"))
# Format as table with kable() - include appropriate column names and caption
# Use filter() to select 2-3 counties from your county_reliability data
# Store the selected counties in a variable called selected_counties
selected_counties = top5_byMOE %>%
filter(med_household_incomeE == 55071 | med_household_incomeE == 47913)
# Display the selected counties with their key characteristics
# Show: county name, median income, MOE percentage, reliability category
selected_counties %>%
select(county_data_2022_clean, med_household_incomeE, med_income_moe_pct, med_income_confi) %>%
kable(
caption = "**Schoolcraft and Gogebic County Income Demographics**",
align = c("l", "c", "c", "r"),
row.names = TRUE,
col.names = c("County Name", "Median Income", "MOE (%)", "Reliability Category")
)
# Define your race/ethnicity variables with descriptive names
race_vars <- get_acs(geography = "tract",
survey = "acs5",
variables = c(white = "B03002_003",
black = "B03002_004",
hisp_latinx = "B03002_012",
total_pop = "B03002_001"),
year = 2022,
state = "MI",
county = c("153", "053"), #Schoolcraft is 26153, Gogebic is 26053.
output = "wide"
)
# Use get_acs() to retrieve tract-level data
# Hint: You may need to specify county codes in the county parameter
# Calculate percentage of each group using mutate()
# Create percentages for white, Black, and Hispanic populations
race_vars_percts = race_vars %>%
mutate(perct_white = (whiteE/total_popE) * 100,
perct_black = (blackE/total_popE) * 100,
perct_latinx = (hisp_latinxE/total_popE) * 100,
tract_name = str_extract(NAME, "Census Tract \\d+"),
county_name = str_extract(NAME, "[A-Za-z]+ County" )
)
# Add readable tract and county name columns using str_extract() or similar MUTATE()& Extract()
# Find the tract with the highest percentage of Hispanic/Latino residents
# Hint: use arrange() and slice() to get the top tract
max_latinx <- race_vars_percts %>%
arrange(desc(perct_latinx))%>%
slice(1)
kable(max_latinx,
caption = "HELP",
)
# Calculate average demographics by county using group_by() and summarize()
# Show: number of tracts, average percentage for each racial/ethnic group
avg_demo <- race_vars_percts %>%
group_by(county_name) %>%
summarize(
ntracts    = n(),
white_avg  = mean(perct_white, na.rm = TRUE),
black_avg  = mean(perct_black, na.rm = TRUE),
latinx_avg = mean(perct_latinx, na.rm = TRUE)
)
# Create a nicely formatted table of your results using kable()
kable(avg_demo,
caption = "Average Demographic Per County",
align = c("l", "c", "c", "c", "r"),
col.names = c("County Name", "No. of Tracts", "% White", "% Black", "% LatinX"),
row.names = TRUE
)
# Calculate MOE percentages for white, Black, and Hispanic variables
# Hint: use the same formula as before (margin/estimate * 100)
# Create a flag for tracts with high MOE on any demographic variable
# Use logical operators (| for OR) in an ifelse() statement
moe_gogegic_schoolcraft = race_vars_percts %>%
mutate(
MOE_white = (whiteM/whiteE) * 100,
MOE_black = (blackM/blackE) * 100,
MOE_latinx = (hisp_latinxM/hisp_latinxE) * 100,
MOE_flag = ifelse(MOE_white > 15 | MOE_black > 15 |  MOE_latinx > 15,
TRUE,
FALSE
)
)
# Create summary statistics showing how many tracts have data quality issues
moe_summary_county <- moe_gogegic_schoolcraft %>%
group_by(county_name) %>%
summarize(
total_tracts    = n(),
high_MOE_tracts = sum(MOE_flag, na.rm = TRUE),
pct_high_MOE    = round(100 * high_MOE_tracts / total_tracts, 1)
)
kable (
moe_summary_county,
caption = "**MOE Summary**",
row.names = TRUE,
col.names = c("County", "Total Tracts", "High MOE Tracts", "Percent High MOE(%)"),
align = c("l","c","c","r")
)
# Group tracts by whether they have high MOE issues
# Calculate average characteristics for each group:
# - population size, demographic percentages
moe_patterns <- moe_gogegic_schoolcraft %>%
group_by(county_name, MOE_flag) %>%
summarize(
avg_pop     = mean(total_popE, na.rm = TRUE),
avg_white   = mean(perct_white, na.rm = TRUE),
avg_black   = mean(perct_black, na.rm = TRUE),
avg_latinx  = mean(perct_latinx, na.rm = TRUE),
n_tracts    = n()
)
kable(moe_patterns,
caption = "**Comparison of High-MOE vs Reliable Tracts**",
align = c("l", "c", "c", "c","c","c","r"),
col.names = c("County", "Flag Status", "Population Average", "% White Avg", "% Black Avg", "% LatinX", "Tracts Quantity"),
digits = 2
)
# Create a summary table using your county reliability data
# Include: county name, median income, MOE percentage, reliability category
sum_table = MI_county_reliablility %>%
select(
county_name = county_data_2022_clean,
med_inc = med_household_incomeE,
moe_pct = med_income_moe_pct,
conf_interval = med_income_confi
) %>%
mutate(
recs = case_when(
moe_pct < 5 ~ "Safe for algorithmic decisions",
moe_pct < 10 ~ "Use with caution - monitor outcomes",
TRUE ~ "Requires manual review or additional data"
)
)
# Add a new column with algorithm recommendations using case_when():
# - High Confidence: "Safe for algorithmic decisions"
# - Moderate Confidence: "Use with caution - monitor outcomes"
# - Low Confidence: "Requires manual review or additional data"
kable(sum_table,
caption = "**Algorithm Recommendations**",
col.names = c("County", "Median Income", "MOE (%)", "Confidence Interval", "Recommendation"),
digits = 2,
align = c("l", "c", "c", "c", "r"),
)
# Format as a professional table with kable()
